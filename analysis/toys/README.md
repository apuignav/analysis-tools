Toys
====

Scripts for toy data generation and fitting.


Toy generation
--------------

The `generate_toys.py` script creates the toy datasets.
Its output is written into a `pandas.HDFStore` file, which contains two trees:

  - `data` contains a `pandas.DataFrame` with the generated events, as well as the ID of the job used to generate it (in case the script is run in standalone mode, this ID is 'local').
  - `toy_info` contains the information for each job: seed, number of events and values of the generation parameters.

This information should be enough to reconstruct any generation process. 

It's important to realize that the user has no control on the output locations, as these are all controlled by the `analysis.utils.paths` module.
Generated data are stored in the `analysis/data/toys/gen` folder, and the file name is `{name}.hdf`, where `name` is defined in the configuration file.

The only possibility for location configuration is the use of the `link-from` configuration, which actually builds the folder hierarchy in the specified folder (typically in a large storage space) and symlinks everything to the current one.

Toys are configured with YAML files, such as:

```yaml
name: Test
nevents: 23
folding: S4
pdfs:
    angular:
        pdf: signal
        parameters:
            - S4: 1.0
    mass
        pdf: doublecb
    q2
        pdf: flat
```

The `pdfs` key configures the generation PDFs, and details on how to configure them can be found in [the physics README](../physics/README.md).
**Note**: Parameter renaming is ignored in this case to help with portability.


### Trick

If using the `link-from` option, several users can share the same toys if the config file is committed (or we know its location) and the same `link-from` is given.
When executin `submit_generate_toys.py`, it checks for the existence of the toy file.
If it does, it is simply symlinked to the user directory, thus making everything work.


Toy fitting
-----------

The `fit_toys.py` script fits the data.
Its output is written into a `pandas.HDFStore` file containing two trees:

  - `fit_results` contains (a) the model name and strategy of the fit, (b) the generation values (with the `_{gen}` suffix), and (c) the final value and errors, toy by toy, of each fit parameter.
  Since `pandas` doesn't happily support objects with uncertainties, for each parameter `par` we store 4 columns:
  `{par}` is the parameter value, `{par}_err_hesse` contains the Hessian error (from `RooFit`'s `getError`), and `{par}_err_plus` and `{par}_err_minus` contain the asymmetric Minos errors.
  Additionally, the per-toy pulls are also computed, and saved as `{par}_pull_hesse` and `{par}_pull_minos`.
  Of course, this is done only for those parameters that match the generation.
  - `gen_info` contains the information of the input datasets used to extract the fit input data.

As before, the user has no control on the output location, as these are all controlled by the `analysis.utils.paths` module.
Generated data are stored in the `analysis/data/toys/fit` folder, and the file name is `{name}.hdf`, where `name` is defined in the configuration file.
As before, `link-from` can also be used.

Fits are configured with YAML files, such as:

```yaml
name: SignalFit
fit:
    nfits: 10
    minos: yes
    models:
        - model
    strategies:
        - simple
model:
    signal:
        initial-yield: 989
        pdfs:
            angular:
                pdf: signal
                folding: S4
data:
    signal:
      source: SignalTest
      nevents: 1000
```

The `fit` key configures the fit work, setting the total number of samples to be taken and the fit configuration (currently only `minos` is supported).

The `model` key configures the default fit model.
However, several different fit models (for the same dataset) can be specified with the `fit/models` keys;
in this case, the names specified in such key are used to search for models.
The configuration of each fit model is discussed in [the corresponding `README.md`](../fit/README.md).

Similarly, several fit strategies can be specified with the `fit/strategies` key.
A basic one (`model.fitTo`) is implemented with the name `simple`, but more can be registered by using the `analysis.fit.register_fit_strategy` function (more details [here](../fit/README.md)).
These fit strategies should consist of a function that gets the model (PDF), the dataset to fit and the fit options, and return a `RooFitResult`.

The `data` key is used to specify the input data for each toy.
Each of the entries is used to load a toy generated by `generate_toys.py` using its name (`source`), and configures the number of entries to sample from the input data set (`nevents`).
Note that the number of events will be Poisson-fluctuated since the fit is always extended.
In the end, all sampled datasets are merged and used as the data for the fit.


Submitting to a batch system
----------------------------

Toy production and fitting is a highly parallel job, and to allow this the `submit_toys.py` script is provided.
This script is configured with the same YAML files as the single toy script, with the extra mandatory key `nevents-per-job` (`nfits-per-job`), which specifies the number of events produced (fits performed) per job (then, `nevents` (`nfits`) controls the *total* amount of toys produced).
Additionally, the `runtime` key, written in the `HH:MM:SS` format, allows to control cluster execution (defaults to `08:00:00`).
The previous example could then be rewritten as:

```yaml
name: SignalFit
fit:
    nfits: 100
    minos: yes
    nfits-per-job: 10
model:
    signal:
        initial-yield: 989
        pdfs:
            angular:
                pdf: signal
                folding: S4
data:
    signal:
      source: SignalTest
      nevents: 1000
```

Whenever a configuration file is used in `submit_toys.py`, it is copied to the same folder as the `.hdf` file with the `.yml` extension.
This allows to keep track of all productions in a sustainable way, since toys will not be overridden unless explicitly stated when executing the script.

In addition to this fixed submission, it is possible to submit "parametric" jobs, that is, scans on certain variables.
These are specified through the `scan` key, a list each element of which is a dictionary of `key -> values to scan`.
The keys are specified as a "route" to the parameter that we want to change, while the values to scan can be specified in two different ways:

  - `V X [Y ...]` corresponds to the explicit specification of the values to use for the scan.
  - `R min max step` corresponds to a range that goes from `min` to `max` in steps of `step` (floats are allowed).

Within each entry of the list, the values to scan are paired in a one-to-one correspondence, while the different elements of the list are combined in a cartesian product.
To achieve different toy names, the keys can be used to format the `name` of the toy.
Modifying the previous example,

```yaml
name: SignalFit_{model/signal/pdfs/angular/folding}_{data/signal/nevents}
fit:
    nfits: 100
    minos: yes
    nfits-per-job: 10
model:
    signal:
        pdfs:
            angular:
                pdf: signal
data:
    signal:
      source: SignalTest
scan:
    - data/signal/nevents: R 1000 3000 1000
      model/signal/initial-yield: R 1001 3001 1001
    - model/signal/pdfs/angular/folding: V S4 S9
```

Will generate 4 sets of toys:

  - `SignalFit_S4_1000` with 1000 `nevents`, `initial-yield` equal to 1001 and S4 folding.
  - `SignalFit_S4_2000` with 2000 `nevents`, `initial-yield` equal to 2001 and S4 folding.
  - `SignalFit_S9_1000` with 1000 `nevents`, `initial-yield` equal to 1001 and S9 folding.
  - `SignalFit_S9_2000` with 2000 `nevents`, `initial-yield` equal to 2001 and S9 folding.

