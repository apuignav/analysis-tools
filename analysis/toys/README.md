Toys
====

Scripts for toy data generation and fitting.


Toy generation
--------------

The `generate_toys.py` script creates the toy datasets.
Its output is written into a `pandas.HDFStore` file, which contains two trees:

  - `data` contains a `pandas.DataFrame` with the generated events, as well as the ID of the job used to generate it (in case the script is run in standalone mode, this ID is 'local').
  - `toy_info` contains the information for each job: seed, number of events and values of the generation parameters.

This information should be enough to reconstruct any generation process. 

It's important to realize that the user has no control on the output locations, as these are all controlled by the `analysis.utils.paths` module.
Generated data are stored in the `analysis/data/toys/gen` folder, and the file name is `{name}.hdf`, where `name` is defined in the configuration file.

The only possibility for location configuration is the use of the `link-from` configuration, which actually builds the folder hierarchy in the specified folder (typically in a large storage space) and symlinks everything to the current one.

Toys are configured with YAML files, such as:

```yaml
name: Test
nevents: 23
folding: S4
pdfs:
    angular:
        pdf: signal
        parameters:
            - S4: 1.0
    mass:
        pdf: doublecb
    q2:
        pdf: flat
```

The `pdfs` key configures the generation PDFs, and details on how to configure them can be found in [the physics README](../physics/README.md).
**Note**: Parameter renaming is ignored in this case to help with portability.


### Trick

If using the `link-from` option, several users can share the same toys if the config file is committed (or we know its location) and the same `link-from` is given.
When executing `submit_generate_toys.py`, it checks for the existence of the toy file.
If it does, it is simply symlinked to the user directory, thus making everything work.


Toy fitting
-----------

The `fit_toys.py` script fits the data.
Its output is written into a `pandas.HDFStore` file containing two trees:

  - `fit_results` contains (a) the model name and strategy of the fit, (b) the generation values (with the `_{gen}` suffix), and (c) the final value and errors, toy by toy, of each fit parameter.
  Since `pandas` doesn't happily support objects with uncertainties, for each parameter `par` we store 4 columns:
  `{par}` is the parameter value, `{par}_err_hesse` contains the Hessian error (from `RooFit`'s `getError`), and `{par}_err_plus` and `{par}_err_minus` contain the asymmetric Minos errors.
  Additionally, the per-toy pulls are also computed, and saved as `{par}_pull_hesse` and `{par}_pull_minos`.
  Of course, this is done only for those parameters that match the generation.
  - `gen_info` contains the information of the input datasets used to extract the fit input data.

As before, the user has no control on the output location, as these are all controlled by the `analysis.utils.paths` module.
Generated data are stored in the `analysis/data/toys/fit` folder, and the file name is `{name}.hdf`, where `name` is defined in the configuration file.
As before, `link-from` can also be used.

Fits are configured with YAML files, such as:

```yaml
name: SignalFit
fit:
    nfits: 10
    minos: yes
    models:
        - model
    strategies:
        - simple
model:
    signal:
        initial-yield: 989
        pdfs:
            angular:
                pdf: signal
                folding: S4
data:
    signal:
      source: SignalTest
      nevents: 1000
```

The `fit` key configures the fit work, setting the total number of samples to be taken and the fit configuration (currently only `minos` is supported).

The `model` key configures the default fit model.
However, several different fit models (for the same dataset) can be specified with the `fit/models` keys;
in this case, the names specified in such key are used to search for models.
The configuration of each fit model is discussed in [the corresponding `README.md`](../fit/README.md).

Similarly, several fit strategies can be specified with the `fit/strategies` key.
A basic one (`model.fitTo`) is implemented with the name `simple`, but more can be registered by using the `analysis.fit.register_fit_strategy` function (more details [here](../fit/README.md)).
These fit strategies should consist of a function that gets the model (PDF), the dataset to fit and the fit options, and return a `RooFitResult`.

The `data` key is used to specify the input data for each toy.
Each of the entries is used to load a toy generated by `generate_toys.py` using its name (`source`), and configures the number of entries to sample from the input data set (`nevents`).
If a simultaneous fit is performed, the `category` key has to be specified in the data with the name of the category.
This does *not* select the given category from the data but *labels* the given data as having that category. 
In the end, all sampled datasets are merged and used as the data for the fit.
Special care needs to be taken when extended fits are involved:
if the fit model is extended (if more than one is specified, they all need to be either extended or not extended) the number of entries sampled from each input dataset will be varied according to a Poisson distribution;
however, if any of the yields in any of the fit models is fixed, a warning will be issued, as in this case one may not want to do the Poisson variation, which can be disabled by adding a `poisson: false` entry in the suitable data source (the warning will not disappear).


Submitting to a batch system
----------------------------

Toy production and fitting is a highly parallel job, and to allow this the `submit_toys.py` script is provided.
This script is configured with the same YAML files as the single toy script, with the extra mandatory key `nevents-per-job` (`nfits-per-job`), which specifies the number of events produced (fits performed) per job (then, `nevents` (`nfits`) controls the *total* amount of toys produced).
Additionally, the `runtime` key, written in the `HH:MM:SS` format, allows to control cluster execution (defaults to `08:00:00`).
The previous example could then be rewritten as:

```yaml
name: SignalFit
fit:
    nfits: 100
    minos: yes
    nfits-per-job: 10
model:
    signal:
        initial-yield: 989
        pdfs:
            angular:
                pdf: signal
                folding: S4
data:
    signal:
      source: SignalTest
      nevents: 1000
```

Whenever a configuration file is used in `submit_toys.py`, it is copied to the same folder as the `.hdf` file with the `.yml` extension.
This allows to keep track of all productions in a sustainable way, since toys will not be overridden unless explicitly stated when executing the script.

In addition to this fixed submission, it is possible to submit "parametric" jobs, that is, scans on certain variables.
These are specified through the `scan` key, a list each element of which is a dictionary of `key -> values to scan`.
The keys are specified as a "route" to the parameter that we want to change, while the values to scan can be specified in two different ways:

  - `V X [Y ...]` corresponds to the explicit specification of the values to use for the scan.
  - `R min max step` corresponds to a range that goes from `min` to `max` in steps of `step` (floats are allowed).

Within each entry of the list, the values to scan are paired in a one-to-one correspondence, while the different elements of the list are combined in a cartesian product.
To achieve different toy names, the keys can be used to format the `name` of the toy.
Modifying the previous example,

```yaml
name: SignalFit_{model/signal/pdfs/angular/folding}_{data/signal/nevents}
fit:
    nfits: 100
    minos: yes
    nfits-per-job: 10
model:
    signal:
        pdfs:
            angular:
                pdf: signal
data:
    signal:
      source: SignalTest
scan:
    - data/signal/nevents: R 1000 3000 1000
      model/signal/initial-yield: R 1001 3001 1001
    - model/signal/pdfs/angular/folding: V S4 S9
```

Will generate 4 sets of toys:

  - `SignalFit_S4_1000` with 1000 `nevents`, `initial-yield` equal to 1001 and S4 folding.
  - `SignalFit_S4_2000` with 2000 `nevents`, `initial-yield` equal to 2001 and S4 folding.
  - `SignalFit_S9_1000` with 1000 `nevents`, `initial-yield` equal to 1001 and S9 folding.
  - `SignalFit_S9_2000` with 2000 `nevents`, `initial-yield` equal to 2001 and S9 folding.



Toys for systematics
--------------------

Toys for calculating systematic uncertainties can be run with the `syst_toys` script.
This script needs a simple input config with a few keys:

	- `name` specifies de systematics run name, which is used to store the results using the `analysis.utils.paths.get_toy_fit_path` function.
	- `fit` gives details on the fitting procedure, similarly to `fit_toys`.
	In this case, only one fit model can be specified, `model` being the default.
	- `acceptance` optionally specifies a generation/fit acceptance.
	- `randomizer` configures the `RandomizerToys` class to use.
	The only mandatory entry is `type`, which specifies the type of randomizer that is run.
	Currently there are two registered randomizer types (as done in `analysis.toys.randomizers`): `fixed_params` and `acceptance`.

Systematic toys are performed in the following way:

	1. A suitable `Randomizer` object is loaded according to the configuration in `syst`.
	2. A dataset is generated from the fit model applying a randomization step, which is different for each type of systematic study.
	3. The generated dataset is fit with the nominal fit model.
  4. The generated dataset is fit with the randomized model as if it was the nominal.
	4. Steps 2 and 3 are repeated until a total of `fit/nfits-per-job` generate/fit loops have been performed.

### Fixed parameters systematics

This type of toys, identified by the `type: fixed_params` key, is used to perform variations on parameters fixed from a previous fit.
To specify the parameters to vary, one needs to fill the `params` key with a list of fit results and corresponding parameters to vary.
For example,

```yaml
syst:
	type: fixed_params
	params:
    - result: MCFit1
      param_names:
        mc_fit1_param1: mymodel_param1
				mc_fit1_param2: mymodel_param2
		- result: MCFit2
		  param_names:
				mc_fit2_param1: mymodel_param3
				mc_fit2_param2: mymodel_param4
```

would load fit results `MCFit1` and `MCFit2` using the `get_fit_result` path function.
From the first one, the values of `mc_fit1_param1` and  `mc_fit1_param2` would be applied to `mymodel_param1` and `mymodel_param2`, respectively, where `mymodel_paramX` correspond to the name of parameters in the fit model specified in the configuration;
an analogous operation is performed for `MCFit2`.
The covariance matrix used to generate the randomized dataset is a block-diagonal matrix made up with the covariance matrices of `MCFit1` and `MCFit2`.

### Acceptance systematics

This type of toys, identified by the `type: acceptance` key, is used to assess the effects of the uncertainties of the used acceptance in the fit.
It doesn't need any special configuration:
the `randomize` method of the `analysis.efficiency.Acceptance` class is used in the randomization step, and the fit is performed with the nominal one.
